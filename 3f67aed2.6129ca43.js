(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{156:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return b}));var a=t(0),r=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=r.a.createContext({}),d=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=d(e.components);return r.a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=d(t),u=a,b=p["".concat(o,".").concat(u)]||p[u]||m[u]||i;return t?r.a.createElement(b,s(s({ref:n},l),{},{components:t})):r.a.createElement(b,s({ref:n},l))}));function b(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=u;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=t[l];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},98:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return s})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return d}));var a=t(3),r=t(7),i=(t(0),t(156)),o={title:"Schema Guide"},s={unversionedId:"guides/schema-guide",id:"guides/schema-guide",isDocsHomePage:!1,title:"Schema Guide",description:"This guide in under development. We are moving some shared Schema information from describe, extract, validate, and transform guides to this guide.",source:"@site/../docs/guides/schema-guide.md",slug:"/guides/schema-guide",permalink:"/docs/guides/schema-guide",editUrl:"https://github.com/frictionlessdata/frictionless-py/edit/master/docs/../docs/guides/schema-guide.md",version:"current",lastUpdatedBy:"roll",lastUpdatedAt:1613460084,sidebar:"guides",previous:{title:"Resource Guide",permalink:"/docs/guides/resource-guide"},next:{title:"Field Guide",permalink:"/docs/guides/field-guide"}},c=[{value:"Schema Options",id:"schema-options",children:[{value:"Schema",id:"schema",children:[]},{value:"Sync Schema",id:"sync-schema",children:[]},{value:"Patch Schema",id:"patch-schema",children:[]}]},{value:"Infer Options",id:"infer-options",children:[{value:"Infer Type",id:"infer-type",children:[]},{value:"Infer Names",id:"infer-names",children:[]},{value:"Infer Volume",id:"infer-volume",children:[]},{value:"Infer Confidence",id:"infer-confidence",children:[]},{value:"Infer Missing Values",id:"infer-missing-values",children:[]}]}],l={toc:c};function d(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"This guide in under development. We are moving some shared Schema information from describe, extract, validate, and transform guides to this guide.")),Object(i.b)("h2",{id:"schema-options"},"Schema Options"),Object(i.b)("p",null,"By default, a schema for a table is inferred under the hood but we can also pass it explicitly."),Object(i.b)("h3",{id:"schema"},"Schema"),Object(i.b)("p",null,"The most common way is providing a schema argument to the Table constructor. For example, let's make the ",Object(i.b)("inlineCode",{parentName:"p"},"id")," field be a string instead of an integer:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},"from frictionless import Table, Schema, Field\n\nschema = Schema(fields=[Field(name='id', type='string'), Field(name='name', type='string')])\nwith Table('data/capital-3.csv', schema=schema) as table:\n  pprint(table.schema)\n  pprint(table.read_rows())\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"{'fields': [{'name': 'id', 'type': 'string'},\n            {'name': 'name', 'type': 'string'}]}\n[Row([('id', '1'), ('name', 'London')]),\n Row([('id', '2'), ('name', 'Berlin')]),\n Row([('id', '3'), ('name', 'Paris')]),\n Row([('id', '4'), ('name', 'Madrid')]),\n Row([('id', '5'), ('name', 'Rome')])]\n")),Object(i.b)("h3",{id:"sync-schema"},"Sync Schema"),Object(i.b)("p",null,"There is a way to sync provided schema based on a header row's field order. It's very useful when you have a schema that describes a subset or a superset of the table's fields:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},"from frictionless import Table, Schema, Field\n\n# Note the order of the fields\nschema = Schema(fields=[Field(name='name', type='string'), Field(name='id', type='string')])\nwith Table('data/capital-3.csv', schema=schema, sync_schema=True) as table:\n  pprint(table.schema)\n  pprint(table.read_rows())\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"{'fields': [{'name': 'id', 'type': 'string'},\n            {'name': 'name', 'type': 'string'}]}\n[Row([('id', '1'), ('name', 'London')]),\n Row([('id', '2'), ('name', 'Berlin')]),\n Row([('id', '3'), ('name', 'Paris')]),\n Row([('id', '4'), ('name', 'Madrid')]),\n Row([('id', '5'), ('name', 'Rome')])]\n")),Object(i.b)("h3",{id:"patch-schema"},"Patch Schema"),Object(i.b)("p",null,"Sometimes we just want to update only a few fields or some schema's properties without providing a brand new schema. For example, the two examples above can be simplified as:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},"from frictionless import Table\n\nwith Table('data/capital-3.csv', patch_schema={'fields': {'id': {'type': 'string'}}}) as table:\n  pprint(table.schema)\n  pprint(table.read_rows())\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"{'fields': [{'name': 'id', 'type': 'string'},\n            {'name': 'name', 'type': 'string'}]}\n[Row([('id', '1'), ('name', 'London')]),\n Row([('id', '2'), ('name', 'Berlin')]),\n Row([('id', '3'), ('name', 'Paris')]),\n Row([('id', '4'), ('name', 'Madrid')]),\n Row([('id', '5'), ('name', 'Rome')])]\n")),Object(i.b)("h2",{id:"infer-options"},"Infer Options"),Object(i.b)("p",null,"Let's explore some handy options to customize the infer process. All of them are available in some form for all the functions above and for different invocation types: in Python, in CLI, or for a REST server."),Object(i.b)("h3",{id:"infer-type"},"Infer Type"),Object(i.b)("p",null,"This option allows manually setting all the field types to a given type. It's useful when you need to skip data casting (setting ",Object(i.b)("inlineCode",{parentName:"p"},"any")," type) or have everything as a string (setting ",Object(i.b)("inlineCode",{parentName:"p"},"string")," type):"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},"! frictionless describe data/country-1.csv --infer-type string\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"---\nmetadata: data/country-1.csv\n---\n\ncompression: 'no'\ncompressionPath: ''\ncontrol:\n  newline: ''\ndialect: {}\nencoding: utf-8\nformat: csv\nhashing: md5\nname: country-1\npath: data/country-1.csv\nprofile: tabular-data-resource\nquery: {}\nschema:\n  fields:\n    - name: id\n      type: string\n    - name: neighbor_id\n      type: string\n    - name: name\n      type: string\n    - name: population\n      type: string\nscheme: file\nstats:\n  bytes: 100\n  fields: 4\n  hash: 4204f087f328b70c854c03403ab448c4\n  rows: 5\n")),Object(i.b)("h3",{id:"infer-names"},"Infer Names"),Object(i.b)("p",null,"Sometimes you don't want to use existent header row to compose field names. It's possible to provide custom names:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},'from frictionless import describe\n\nresource = describe("data/country-1.csv", infer_names=["f1", "f2", "f3", "f4"])\nprint(resource.schema.field_names)\n')),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"['f1', 'f2', 'f3', 'f4']\n")),Object(i.b)("h3",{id:"infer-volume"},"Infer Volume"),Object(i.b)("p",null,"By default, Frictionless will use the first 100 rows to detect field types. This can be customized. The following code will be slower but the result can be more accurate"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},'from frictionless import describe\n\nresource = describe("data/country-1.csv", infer_volume=1000)\n')),Object(i.b)("h3",{id:"infer-confidence"},"Infer Confidence"),Object(i.b)("p",null,"By default, Frictionless uses 0.9 (90%) confidence level for data types detection. It means that it there are 9 integers in a field and one string it will be inferred as an integer. If you want a guarantee that an inferred schema will conform to the data you can set it to 1 (100%):"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},'from frictionless import describe\n\nresource = describe("data/country-1.csv", infer_confidence=1)\n')),Object(i.b)("h3",{id:"infer-missing-values"},"Infer Missing Values"),Object(i.b)("p",null,"Missing Values is an important concept in data description. It provides information about what cell values should be considered as nulls. We can customize the defaults:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},'from pprint import pprint\nfrom frictionless import describe\n\nresource = describe("data/country-1.csv", infer_missing_values=["", "67"])\npprint(resource.schema.missing_values)\npprint(resource.read_rows())\n')),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"['', '67']\n[Row([('id', 1),\n      ('neighbor_id', None),\n      ('name', 'Britain'),\n      ('population', None)]),\n Row([('id', 2), ('neighbor_id', 3), ('name', 'France'), ('population', None)]),\n Row([('id', 3), ('neighbor_id', 2), ('name', 'Germany'), ('population', 83)]),\n Row([('id', 4), ('neighbor_id', 5), ('name', 'Italy'), ('population', 60)]),\n Row([('id', 5), ('neighbor_id', 4), ('name', 'Spain'), ('population', 47)])]\n")),Object(i.b)("p",null,"As we can see, the textual values equal to \"67\" are now considered nulls. Usually, it's handy when you have data with values like: '-', 'n/a', and similar."))}d.isMDXComponent=!0}}]);